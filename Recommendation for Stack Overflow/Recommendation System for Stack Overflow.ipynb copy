{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "2846bd07",
   "metadata": {},
   "source": [
    "# Recommendation System for Stack Overflow Users\n",
    "## Table of Contents\n",
    "1. [Introduction](#Introduction)\n",
    "2. [Implementation](#Implementation)\n",
    "3. [Results and Conclusion](#Results-and-Conclusion)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8904b578",
   "metadata": {},
   "source": [
    "# Introduction\n",
    "Any company providing services through the internet faces a daunting challenge: how does one keep customers coming back in a world where time and attention are becoming increasingly limited? Designing a convenient, user-friendly website and effective advertising will only go so far if users do not see a need to engage with the company's services. So if Company A wants to keep users coming back, what better way to do this than by showing users similar items they might enjoy? For example, a music streaming service can increase the likelihood users coming back by recommending them songs from their favorite genre. This is the idea behind many [recommender systems](https://en.wikipedia.org/wiki/Recommender_system). In this project, we will create a simple recommender system for [Stack Overflow](https://stackoverflow.com) users.\n",
    "\n",
    "It is worth noting that there are many different angles we can take with this approach. Most of the \"big questions\" such as, \"if a user is asking a question, can we show them similar questions?\" or \"Based on the text in the user's question, can we recommend what tags they should attach to the question?\" require the use of [natural language processing](https://en.wikipedia.org/wiki/Natural_language_processing) (NLP). While this is something I am very much interested, I am still learning about different NLP techniques, and therefore I will postpone using any NLP approaches.\n",
    "\n",
    "Instead, I seek to answer the following two questions:\n",
    "1. If a user has posted at least one question, can we recommend them other questions that might interest them?\n",
    "2. Can we \"categorize\" a user? That is, if a user has interacted with certain tags, can we recommend them questions they'll enjoy?\n",
    "\n",
    "Both questions can be answered by building a [content-based](https://en.wikipedia.org/wiki/Recommender_system#Content-based_filtering) recommender system. To report which questions are most similar, I will use the [$\\underline{k}$-nearest neighbors algorithm](https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm) ($k$-NN) to cluster the questions, with the idea that two questions are \"similar\" if their [Jaccard index](https://en.wikipedia.org/wiki/Jaccard_index) is sufficiently large. Conveniently, the [last project](https://nbviewer.org/github/daniel-rossano/Data-Analysis-Projects/blob/main/Visualizing%20Stack%20Overflow%20Tags/Visualizing%20Stack%20Overflow%20Tags%20Using%20KeplerMapper.ipynb) provides much of the information needed to find the Jaccard index of the questions (though it will certainly need to be adjusted, since that project was concerned solely with tags and not the questions themselves!). This also ties into the [persistent homology project](https://github.com/daniel-rossano/Data-Analysis-Projects/blob/main/Persistent%20Homology%20SO%20Tags/Persistent%20Homology%20of%20Stack%20Overflow%20Tags.ipynb) I did, because that project used the Jaccard index to represent Stack Overflow tags as an abstract metric space."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fd91abae",
   "metadata": {},
   "source": [
    "# Implementation\n",
    "A more descriptive, yet still concise overview of what I want to do is as follows:\n",
    "* Query the Stack Overflow Data Explorer for a random sample of Stack Overflow User IDs, as the IDs for every question that each user has made, and the tag(s) attached to each of those questions. The query I use will specifically ignore users who have not made any questions, as such users would essentially \"take up empty space\" in the sample and leave room for greater inaccuracies in the recommendations.\n",
    "* Consider two questions to be similar if their tag(s) have a sufficiently large Jaccard index, i.e., two questions are similar if they use several of the same tags\n",
    "* For a given question, we will look at its Jaccard index with all other questions in the sample, and then report back the $10$ most similar questions ($10$ questions with the highest Jaccard index). We will, of course, exclude the input if it happens to be in the sample\n",
    "\n",
    "Since the SQL query here is more advanced than in the previous projects, where I only needed to obtain a random sample of any type of post with a nonzero number of tags, I will explicitly write the query I used to obtain all the necessary information:\n",
    "\n",
    "`SELECT \n",
    "    Users.Id AS 'User ID', \n",
    "    Posts.Id AS 'Question ID', \n",
    "    Posts.Tags AS 'Tags'\n",
    "FROM \n",
    "    (SELECT TOP 50000 Users.Id FROM Users ORDER BY NEWID()) AS Users\n",
    "JOIN \n",
    "    Posts ON Posts.OwnerUserId = Users.Id\n",
    "WHERE\n",
    "    Posts.PostTypeId = 1\n",
    "    AND Posts.DeletionDate IS NULL\n",
    "    AND Posts.ClosedDate IS NULL\n",
    "    AND Posts.CommunityOwnedDate IS NULL\n",
    "`\n",
    "\n",
    "This query fetches a random assortment of users, each of whom has made at least one question. Each row is a user's ID, a question they have made, and the tags they've used for that question. The last few lines narrow down what criteria we allow for questions. The line `Posts.PostTypeId = 1` means we will only consider Stack Overflow *questions* and not articles or answers, because if the end-goal is user *engagement*, I should recommend them something they can participate in. Users should also be recommended questions that have not been deleted or already closed, so that they actulaly have a chance to engage in discussions, hence the lines `AND Posts.DeletionDate IS NULL` and `Posts.ClosedDate IS NULL`. Finally, `AND Posts.CommunityOwnedDate IS NULL` filters out any Community Wiki posts, mostly because such posts are generally more complex to answer, and newer users may feel overwhelmed. In an ideal world where I had direct access to all of the nesessary SO data, I would also filter questions based on creation date, as newer questions ensure the user will have a fair chance to engage in discussion.\n",
    "\n",
    "Now we have all the data we need to create our recommendation system. This can be done surprisingly quickly, in very few lines of code."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "id": "8e5a30b0",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Question ID</th>\n",
       "      <th>Jaccard Index</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>121707</td>\n",
       "      <td>1.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>29729</th>\n",
       "      <td>62591570</td>\n",
       "      <td>0.800000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>49476</th>\n",
       "      <td>52186180</td>\n",
       "      <td>0.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>49474</th>\n",
       "      <td>52172524</td>\n",
       "      <td>0.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10005</th>\n",
       "      <td>23731526</td>\n",
       "      <td>0.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>48408</th>\n",
       "      <td>46346378</td>\n",
       "      <td>0.666667</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>46458</th>\n",
       "      <td>36489300</td>\n",
       "      <td>0.600000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>20518</th>\n",
       "      <td>47698549</td>\n",
       "      <td>0.600000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>20802</th>\n",
       "      <td>45011961</td>\n",
       "      <td>0.600000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>8334</th>\n",
       "      <td>12128125</td>\n",
       "      <td>0.600000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>47889</th>\n",
       "      <td>43674336</td>\n",
       "      <td>0.600000</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "       Question ID  Jaccard Index\n",
       "4           121707       1.000000\n",
       "29729     62591570       0.800000\n",
       "49476     52186180       0.666667\n",
       "49474     52172524       0.666667\n",
       "10005     23731526       0.666667\n",
       "48408     46346378       0.666667\n",
       "46458     36489300       0.600000\n",
       "20518     47698549       0.600000\n",
       "20802     45011961       0.600000\n",
       "8334      12128125       0.600000\n",
       "47889     43674336       0.600000"
      ]
     },
     "execution_count": 69,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import re\n",
    "\n",
    "questions = pd.read_csv(\"UserQuestionSample.csv\") #read in sample\n",
    "\n",
    "input_tag_list = re.findall(r'<(.*?)>', questions.iat[4,2]) #obtain input tags and split them up into a list\n",
    "\n",
    "questions['Tag_List'] = questions.Tags.map(lambda tags: re.findall(r'<(.*?)>',tags)) #turn all the tags from the sample into tag lists and append this list to the sample\n",
    "\n",
    "jaccard_indices = pd.DataFrame(columns = ['Question ID'] ) #initialize jaccard_index dataframe; all we really need are the question IDs\n",
    "jaccard_indices['Question ID'] = questions['Question ID']\n",
    "\n",
    "#map jaccard indices (with respect to the input) into this new dataframe\n",
    "jaccard_indices['Jaccard Index'] = questions.Tag_List.map(lambda x: len(set(x).intersection(set(input_tag_list)))/len(set(x).union(set(input_tag_list))))\n",
    "\n",
    "#now sort by the 10 questions with highest Jaccard indices with the input\n",
    "jaccard_indices.sort_values(by = 'Jaccard Index', ascending = False).head(11)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e053c722",
   "metadata": {},
   "source": [
    "# Results and Conclusion"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9f6bfab9",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
